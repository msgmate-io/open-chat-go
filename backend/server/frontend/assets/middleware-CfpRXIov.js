import{P as T}from"./index-y_eFCewu.js";const w=o=>{let i;const e=new Set,r=(d,s)=>{const y=typeof d=="function"?d(i):d;if(!Object.is(y,i)){const m=i;i=s??(typeof y!="object"||y===null)?y:Object.assign({},i,y),e.forEach(f=>f(i,m))}},n=()=>i,l={setState:r,getState:n,getInitialState:()=>S,subscribe:d=>(e.add(d),()=>e.delete(d))},S=i=o(r,n,l);return l},D=o=>o?w(o):w,N=o=>o;function j(o,i=N){const e=T.useSyncExternalStore(o.subscribe,()=>i(o.getState()),()=>i(o.getInitialState()));return T.useDebugValue(e),e}const R=o=>{const i=D(o),e=r=>j(i,r);return Object.assign(e,i),e},H=o=>o?R(o):R,J={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},O=new Map,_=o=>{const i=O.get(o);return i?Object.fromEntries(Object.entries(i.stores).map(([e,r])=>[e,r.getState()])):{}},k=(o,i,e)=>{if(o===void 0)return{type:"untracked",connection:i.connect(e)};const r=O.get(e.name);if(r)return{type:"tracked",store:o,...r};const n={connection:i.connect(e),stores:{}};return O.set(e.name,n),{type:"tracked",store:o,...n}},P=(o,i={})=>(e,r,n)=>{const{enabled:c,anonymousActionType:p,store:l,...S}=i;let d;try{d=(c??(J?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!d)return o(e,r,n);const{connection:s,...y}=k(l,d,S);let m=!0;n.setState=(t,v,u)=>{const a=e(t,v);if(!m)return a;const h=u===void 0?{type:p||"anonymous"}:typeof u=="string"?{type:u}:u;return l===void 0?(s==null||s.send(h,r()),a):(s==null||s.send({...h,type:`${l}/${h.type}`},{..._(S.name),[l]:n.getState()}),a)};const f=(...t)=>{const v=m;m=!1,e(...t),m=v},g=o(n.setState,r,n);if(y.type==="untracked"?s==null||s.init(g):(y.stores[y.store]=n,s==null||s.init(Object.fromEntries(Object.entries(y.stores).map(([t,v])=>[t,t===y.store?g:v.getState()])))),n.dispatchFromDevtools&&typeof n.dispatch=="function"){const t=n.dispatch;n.dispatch=(...v)=>{t(...v)}}return s.subscribe(t=>{var v;switch(t.type){case"ACTION":if(typeof t.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return I(t.payload,u=>{if(u.type==="__setState"){if(l===void 0){f(u.state);return}Object.keys(u.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const a=u.state[l];if(a==null)return;JSON.stringify(n.getState())!==JSON.stringify(a)&&f(a);return}n.dispatchFromDevtools&&typeof n.dispatch=="function"&&n.dispatch(u)});case"DISPATCH":switch(t.payload.type){case"RESET":return f(g),l===void 0?s==null?void 0:s.init(n.getState()):s==null?void 0:s.init(_(S.name));case"COMMIT":if(l===void 0){s==null||s.init(n.getState());return}return s==null?void 0:s.init(_(S.name));case"ROLLBACK":return I(t.state,u=>{if(l===void 0){f(u),s==null||s.init(n.getState());return}f(u[l]),s==null||s.init(_(S.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return I(t.state,u=>{if(l===void 0){f(u);return}JSON.stringify(n.getState())!==JSON.stringify(u[l])&&f(u[l])});case"IMPORT_STATE":{const{nextLiftedState:u}=t.payload,a=(v=u.computedStates.slice(-1)[0])==null?void 0:v.state;if(!a)return;f(l===void 0?a:a[l]),s==null||s.send(null,u);return}case"PAUSE_RECORDING":return m=!m}return}}),g},L=P,I=(o,i)=>{let e;try{e=JSON.parse(o)}catch(r){console.error("[zustand devtools middleware] Could not parse the received json",r)}e!==void 0&&i(e)};function U(o,i){let e;try{e=o()}catch{return}return{getItem:n=>{var c;const p=S=>S===null?null:JSON.parse(S,void 0),l=(c=e.getItem(n))!=null?c:null;return l instanceof Promise?l.then(p):p(l)},setItem:(n,c)=>e.setItem(n,JSON.stringify(c,void 0)),removeItem:n=>e.removeItem(n)}}const E=o=>i=>{try{const e=o(i);return e instanceof Promise?e:{then(r){return E(r)(e)},catch(r){return this}}}catch(e){return{then(r){return this},catch(r){return E(r)(e)}}}},x=(o,i)=>(e,r,n)=>{let c={storage:U(()=>localStorage),partialize:t=>t,version:0,merge:(t,v)=>({...v,...t}),...i},p=!1;const l=new Set,S=new Set;let d=c.storage;if(!d)return o((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${c.name}', the given storage is currently unavailable.`),e(...t)},r,n);const s=()=>{const t=c.partialize({...r()});return d.setItem(c.name,{state:t,version:c.version})},y=n.setState;n.setState=(t,v)=>{y(t,v),s()};const m=o((...t)=>{e(...t),s()},r,n);n.getInitialState=()=>m;let f;const g=()=>{var t,v;if(!d)return;p=!1,l.forEach(a=>{var h;return a((h=r())!=null?h:m)});const u=((v=c.onRehydrateStorage)==null?void 0:v.call(c,(t=r())!=null?t:m))||void 0;return E(d.getItem.bind(d))(c.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==c.version){if(c.migrate){const h=c.migrate(a.state,a.version);return h instanceof Promise?h.then(b=>[!0,b]):[!0,h]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,a.state];return[!1,void 0]}).then(a=>{var h;const[b,C]=a;if(f=c.merge(C,(h=r())!=null?h:m),e(f,!0),b)return s()}).then(()=>{u==null||u(f,void 0),f=r(),p=!0,S.forEach(a=>a(f))}).catch(a=>{u==null||u(void 0,a)})};return n.persist={setOptions:t=>{c={...c,...t},t.storage&&(d=t.storage)},clearStorage:()=>{d==null||d.removeItem(c.name)},getOptions:()=>c,rehydrate:()=>g(),hasHydrated:()=>p,onHydrate:t=>(l.add(t),()=>{l.delete(t)}),onFinishHydration:t=>(S.add(t),()=>{S.delete(t)})},c.skipHydration||g(),f||m},M=x;export{H as c,L as d,M as p};
