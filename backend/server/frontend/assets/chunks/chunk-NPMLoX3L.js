import{d as w}from"./chunk-BqilOtsp.js";const E=r=>{let i;const t=new Set,o=(l,s)=>{const p=typeof l=="function"?l(i):l;if(!Object.is(p,i)){const y=i;i=s??(typeof p!="object"||p===null)?p:Object.assign({},i,p),t.forEach(f=>f(i,y))}},n=()=>i,c={setState:o,getState:n,getInitialState:()=>m,subscribe:l=>(t.add(l),()=>t.delete(l))},m=i=r(o,n,c);return c},R=r=>r?E(r):E,j=r=>r;function J(r,i=j){const t=w.useSyncExternalStore(r.subscribe,()=>i(r.getState()),()=>i(r.getInitialState()));return w.useDebugValue(t),t}const k=r=>{const i=R(r),t=o=>J(i,o);return Object.assign(t,i),t},H=r=>k,C={},O=new Map,_=r=>{const i=O.get(r);return i?Object.fromEntries(Object.entries(i.stores).map(([t,o])=>[t,o.getState()])):{}},D=(r,i,t)=>{if(r===void 0)return{type:"untracked",connection:i.connect(t)};const o=O.get(t.name);if(o)return{type:"tracked",store:r,...o};const n={connection:i.connect(t),stores:{}};return O.set(t.name,n),{type:"tracked",store:r,...n}},A=(r,i={})=>(t,o,n)=>{const{enabled:d,anonymousActionType:g,store:c,...m}=i;let l;try{l=(d??(C?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!l)return r(t,o,n);const{connection:s,...p}=D(c,l,m);let y=!0;n.setState=(e,S,a)=>{const u=t(e,S);if(!y)return u;const h=a===void 0?{type:g||"anonymous"}:typeof a=="string"?{type:a}:a;return c===void 0?(s?.send(h,o()),u):(s?.send({...h,type:`${c}/${h.type}`},{..._(m.name),[c]:n.getState()}),u)};const f=(...e)=>{const S=y;y=!1,t(...e),y=S},v=r(n.setState,o,n);if(p.type==="untracked"?s?.init(v):(p.stores[p.store]=n,s?.init(Object.fromEntries(Object.entries(p.stores).map(([e,S])=>[e,e===p.store?v:S.getState()])))),n.dispatchFromDevtools&&typeof n.dispatch=="function"){let e=!1;const S=n.dispatch;n.dispatch=(...a)=>{(C?"production":void 0)!=="production"&&a[0].type==="__setState"&&!e&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),e=!0),S(...a)}}return s.subscribe(e=>{var S;switch(e.type){case"ACTION":if(typeof e.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return I(e.payload,a=>{if(a.type==="__setState"){if(c===void 0){f(a.state);return}Object.keys(a.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const u=a.state[c];if(u==null)return;JSON.stringify(n.getState())!==JSON.stringify(u)&&f(u);return}n.dispatchFromDevtools&&typeof n.dispatch=="function"&&n.dispatch(a)});case"DISPATCH":switch(e.payload.type){case"RESET":return f(v),c===void 0?s?.init(n.getState()):s?.init(_(m.name));case"COMMIT":if(c===void 0){s?.init(n.getState());return}return s?.init(_(m.name));case"ROLLBACK":return I(e.state,a=>{if(c===void 0){f(a),s?.init(n.getState());return}f(a[c]),s?.init(_(m.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return I(e.state,a=>{if(c===void 0){f(a);return}JSON.stringify(n.getState())!==JSON.stringify(a[c])&&f(a[c])});case"IMPORT_STATE":{const{nextLiftedState:a}=e.payload,u=(S=a.computedStates.slice(-1)[0])==null?void 0:S.state;if(!u)return;f(c===void 0?u:u[c]),s?.send(null,a);return}case"PAUSE_RECORDING":return y=!y}return}}),v},U=A,I=(r,i)=>{let t;try{t=JSON.parse(r)}catch(o){console.error("[zustand devtools middleware] Could not parse the received json",o)}t!==void 0&&i(t)};function P(r,i){let t;try{t=r()}catch{return}return{getItem:n=>{var d;const g=m=>m===null?null:JSON.parse(m,void 0),c=(d=t.getItem(n))!=null?d:null;return c instanceof Promise?c.then(g):g(c)},setItem:(n,d)=>t.setItem(n,JSON.stringify(d,void 0)),removeItem:n=>t.removeItem(n)}}const T=r=>i=>{try{const t=r(i);return t instanceof Promise?t:{then(o){return T(o)(t)},catch(o){return this}}}catch(t){return{then(o){return this},catch(o){return T(o)(t)}}}},x=(r,i)=>(t,o,n)=>{let d={storage:P(()=>localStorage),partialize:e=>e,version:0,merge:(e,S)=>({...S,...e}),...i},g=!1;const c=new Set,m=new Set;let l=d.storage;if(!l)return r((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${d.name}', the given storage is currently unavailable.`),t(...e)},o,n);const s=()=>{const e=d.partialize({...o()});return l.setItem(d.name,{state:e,version:d.version})},p=n.setState;n.setState=(e,S)=>{p(e,S),s()};const y=r((...e)=>{t(...e),s()},o,n);n.getInitialState=()=>y;let f;const v=()=>{var e,S;if(!l)return;g=!1,c.forEach(u=>{var h;return u((h=o())!=null?h:y)});const a=((S=d.onRehydrateStorage)==null?void 0:S.call(d,(e=o())!=null?e:y))||void 0;return T(l.getItem.bind(l))(d.name).then(u=>{if(u)if(typeof u.version=="number"&&u.version!==d.version){if(d.migrate){const h=d.migrate(u.state,u.version);return h instanceof Promise?h.then(b=>[!0,b]):[!0,h]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,u.state];return[!1,void 0]}).then(u=>{var h;const[b,N]=u;if(f=d.merge(N,(h=o())!=null?h:y),t(f,!0),b)return s()}).then(()=>{a?.(f,void 0),f=o(),g=!0,m.forEach(u=>u(f))}).catch(u=>{a?.(void 0,u)})};return n.persist={setOptions:e=>{d={...d,...e},e.storage&&(l=e.storage)},clearStorage:()=>{l?.removeItem(d.name)},getOptions:()=>d,rehydrate:()=>v(),hasHydrated:()=>g,onHydrate:e=>(c.add(e),()=>{c.delete(e)}),onFinishHydration:e=>(m.add(e),()=>{m.delete(e)})},d.skipHydration||v(),f||y},L=x;export{H as c,U as d,L as p};
